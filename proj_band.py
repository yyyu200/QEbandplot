#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np

def parse_filband(feig, npl=10):
    # feig : filband in bands.x input file
    # npl : number per line, 10 for bands.x, 6 for phonon
    import re

    f=open(feig,'r')
    lines = f.readlines()

    header = lines[0].strip()
    line = header.strip('\n')
    shape = re.split('[,=/]', line)
    nbnd = int(shape[1])
    nks = int(shape[3])
    eig = np.zeros((nks, nbnd+1), dtype=np.float32)

    dividend = nbnd
    divisor = npl
    div = nbnd // npl + 1 if nbnd % npl == 0 else nbnd // npl + 2 
    kinfo=[]
    for index, value in enumerate(lines[1:]):
        value = value.strip(' \n')
        quotient = index // div
        remainder = index % div

        if remainder == 0:
            kinfo.append(value)
        else:
            value = re.split('[ ]+', value)
            a = (remainder - 1) * npl
            b = a + len(value)
            eig[quotient][a:b] = value

    f.close()

    return eig, nbnd, nks, kinfo

def match_pattern_with_line_numbers(pattern, text):
    import re
    line_number = 1
    for line in text.splitlines():
        match = re.search(pattern, line)
        if match:
            yield line_number, match
        line_number += 1

def get_sum_orbit(orb, ntype, ielem, i_soc):
    iorb=np.zeros([ntype,],dtype=np.int32)  # number of projectors for each element
    for i in range(ntype):
        iorb[i]=len(orb[i])
    lorb=np.zeros([ntype,],dtype=np.int32) # number of local orbital for each element
    for i in range(ntype):
        for j in orb[i]:
            if j == 's':
                lorb[i]+=1*i_soc
            elif j == 'p':
                lorb[i]+=3*i_soc
            elif j == 'd':
                lorb[i]+=5*i_soc
            elif j == 'f':
                lorb[i]+=7*i_soc
            else:
                print("unexpect: ",j)
                assert False

    return np.dot(ielem,lorb)

def draw_proj_band(proj_file, bd_file, fig_file):

    eig, nbnd, nks, kinfo = parse_filband(bd_file)

    # oo, orbital index for each kind of color, oo can be generated by the following commands
    #grep '[a-zA-Z]' sno.projwfc_up |grep 2P|awk '{printf( $1-1",")}'
    oo=[[0,9],          # s of Sn atoms 1,2
    [1,2,3,10,11,12],   # pz,px,py of Sn atoms 1,2
    [4,5,6,7,8,13,14,15,16,17], # dz2, dzx, dzy, dx2-y2, dxy of Sn atoms 1,2
    [18,22,26,30],      # s of O atoms 1,2,3,4
    [19,20,21,23,24,25,27,28,29,31,32,33]] # pz,px,py of O atoms 1,2,3,4

    nband=26 # highest valence band for ref
    eig_ref=max(eig[:, nband-1]) # VBM for insulators
    #eig_ref= 0.00 # fermi energy level in scf output for metals

    ymin=-23 # plot range for y-axis
    ymax=10
    lw=0.5 # line width
    
    ielem=np.array([2,4],dtype=np.int32) # number of atoms for each element, 2 Sn atoms and 4 O atoms in the cell

    color=['r','g','orange','cyan','blue']
    label=['Sn s','Sn p','Sn d','O s','O p']

    scale=90.0

    x_ticks=[0,30,60]
    x_labels=['M', r'${\Gamma}$', 'Z']

    # end of (the most often) parameters

    ntype=len(ielem) # number of atom types
    nat = sum(ielem)
    nline_io_header=0  # line number at '    F    F' or '    T    T'
    with open(proj_file,'r') as f:
        for line_number in range(nat+ntype+6+3):
            line = f.readline()
            pattern = r"    [TF]    [TF]"
            for i, match in match_pattern_with_line_numbers(pattern, line):
                if match.group()[9]=='F':
                    i_soc = 1
                elif match.group()[9]=='T':
                    i_soc = 2
                nline_io_header = line_number+1
    assert nline_io_header
    #i_soc = 1 # 1: without soc, 2: soc

    import matplotlib as mpl
    mpl.use('Agg')
    import matplotlib.pyplot as plt

    F=plt.gcf()
    F.set_size_inches([4,5])
    p1=plt.subplot(1, 1, 1)

    # draw bands
    for i in range(nbnd):
        line1=plt.plot(np.arange(0,nks), eig[:,i]-eig_ref,color='grey',linewidth=lw )

    # draw vertical lines, positions specified by list like [0, 30, 60, ...]
    #x_ticks= np.arange(0,nks,30) 
    for vline in x_ticks:
        plt.axvline(x=vline, ymin=ymin, ymax=ymax,linewidth=lw,color='black')

    with open(proj_file,'r') as filproj:
        for i in range(nline_io_header-1):
            l = filproj.readline()

        nlorb = int(l.split()[0])
        check_nlorb=False
        if check_nlorb:
            orb=[['s','p','d'],['s','p']]  # projectors for each element
            _nlorb = get_sum_orbit(orb, ntype, ielem, i_soc)
            assert _nlorb==nlorb

        print ("summary : ", i_soc, nline_io_header, nlorb, nks, nbnd)

        pjmat=np.zeros([nlorb, nks, nbnd], dtype=np.float32)
        
        _ = filproj.readline() # skip '    F    F' line
        for i in range(nlorb):
            _ = filproj.readline() # skip orbit header
            for j in range(nks):
                for k in range(nbnd):
                    pjmat[i,j,k]=float(filproj.readline().split()[2])

    for i in range(len(oo)): # once plot a type
        plt.scatter(-1, ymin-1, 20, c=color[i], alpha=0.5, label=label[i],marker='.',edgecolor='none')# draw an invisible point as the anchor of legend
        for k in range(nbnd): # once plot a band
            s_of_o=np.zeros([nks,],dtype=np.float32) # size of dots for all kpoints in a band
            for j in oo[i]: # gather proj weight for an orbit type, such as all the 'p of Sn', that is pz,px,py of Sn atoms 1,2,...
                s_of_o[:]+=pjmat[j,:,k]

            plt.scatter(np.arange(0,nks), eig[:,k]-eig_ref, s=scale*s_of_o, c=color[i], alpha=0.5, marker='.',edgecolor='none')

    plt.xlim([0,nks-1]) # 201 points
    plt.ylim([ymin,ymax])
    plt.ylabel(r'E (eV)',fontsize=16)
    plt.xticks(x_ticks, x_labels)

    plt.subplots_adjust(left=0.20, right=0.75, top=0.95, bottom=0.1)
    p1.legend(scatterpoints =1, numpoints=1,markerscale=2.0, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.savefig(fig_file,dpi=500)

if __name__ == '__main__':
    draw_proj_band("sno.projwfc_up", "bd2.dat", "pjband.png")
    print("done")
